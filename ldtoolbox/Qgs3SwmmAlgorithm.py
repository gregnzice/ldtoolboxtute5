# -*- coding: utf-8 -*-

"""
/***************************************************************************
 Qgs3Epanet
                                 A QGIS plugin
 Implementation of Epanet within QGIS3.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        Date                 : July 2018
        Copyright            : (C) 2018 by Greg Leonard
        Email                : greg.h.leonard@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Greg Leonard'
__date__ = 'July 2018'
__copyright__ = '(C) 2018 by Greg Leonard'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import os
import getpass
import io
import re
from sys import platform
if platform=='linux' or platform=='darwin':
    import pwd
import subprocess
from operator import itemgetter
from processing.core.ProcessingLog import ProcessingLog
from processing.core.ProcessingConfig import ProcessingConfig, Setting
from PyQt5.QtGui import QIcon
from PyQt5.QtCore import QCoreApplication,QVariant
from qgis.core import (QgsProcessing,
                       QgsMessageLog,
                       QgsFeatureSink,
                       QgsProcessingAlgorithm,
                       QgsProcessingUtils,
                       QgsProcessingParameterString,
                       QgsProcessingParameterDefinition,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterVectorLayer,
                       QgsProcessingException,
                       QgsDefaultValue,
                       QgsVectorLayer,
                       QgsProject,
                       QgsField,
                       QgsFields,
                       QgsWkbTypes,
                       QgsFeature,
                       QgsVectorLayerJoinInfo,
                       Qgis,
                       QgsProcessingParameterFeatureSink)

def convert_date(d):
    month = {'JAN':'01',
             'FEB':'02',
             'MAR':'03',
             'APR':'04',
             'MAY':'05',
             'JUN':'06',
             'JUL':'07',
             'AUG':'08',
             'SEP':'09',
             'OCT':'10',
             'NOV':'11',
             'DEC':'12'}
    m = re.search('^(\S+)-(\d\d)-(\d\d\d\d)$',d) # for date and time saved as timestamps

    return m.group(3)+'-'+month[m.group(1)]+'-'+m.group(2)

class Qgs3SwmmAlgorithm(QgsProcessingAlgorithm):

    TITLE = 'TITLE' #title of the SWMM simulation
    OPTIONS = 'OPTIONS' # analysis options
    REPORT = 'REPORT' # output reporting instructions
    FILES = 'FILES' # interface file options
    RAINGAGES = 'RAINGAGES' # rain gage information
    HYDROGRAPHS = 'HYDROGRAPHS' # unit hydrograph data used to construct RDII inflows
    EVAPORATION = 'EVAPORATION' # evaporation data
    TEMPERATURE = 'TEMPERATURE' # air temperature and snow melt data
    SUBCATCHMENTS = 'SUBCATCHMENTS' # basic subcatchment information
    SUBAREAS = 'SUBAREAS' # subcatchment impervious/pervious sub-area data
    INFILTRATION = 'INFILTRATION' # subcatchment infiltration parameters
    LID_CONTROLS = 'LID_CONTROLS' # low impact development control information
    LID_USAGE = 'LID_USAGE' # assignment of LID controls to subcatchments
    AQUIFERS = 'AQUIFERS' # groundwater aquifer parameters
    GROUNDWATER = 'GROUNDWATER' # subcatchment groundwater parameters
    SNOWPACKS = 'SNOWPACKS' # subcatchment snow pack parameters
    JUNCTIONS = 'JUNCTIONS' # junction node information
    OUTFALLS = 'OUTFALLS' # outfall node information
    DIVIDERS = 'DIVIDERS' # flow divider node information
    STORAGE = 'STORAGE' # storage node information
    CONDUITS = 'CONDUITS' # conduit link information
    PUMPS = 'PUMPS' # pump link information
    ORIFICES = 'ORIFICES' # orifice link information
    WEIRS = 'WEIRS' # weir link information
    OUTLETS = 'OUTLETS' # outlet link information
    XSECTIONS = 'XSECTIONS' # conduit, orifice, and weir cross-section geometry
    TRANSECTS = 'TRANSECTS' # transect geometry for conduits with irregular cross-sections
    LOSSES = 'LOSSES' # conduit entrance/exit losses and flap valves
    CONTROLS = 'CONTROLS' # rules that control pump and regulator operation
    POLLUTANTS = 'POLLUTANTS' # pollutant information
    LANDUSES = 'LANDUSES' # land use categories
    COVERAGES = 'COVERAGES' # assignment of land uses to subcatchments
    BUILDUP = 'BUILDUP' # buildup functions for pollutants and land uses
    WASHOFF = 'WASHOFF' # washoff functions for pollutants and land uses
    TREATMENT = 'TREATMENT' # pollutant removal functions at conveyance system nodes
    INFLOWS = 'INFLOWS' # external hydrograph/pollutograph inflow at nodes
    DWF = 'DWF' # baseline dry weather sanitary inflow at nodes
    PATTERNS = 'PATTERNS' # periodic variation in dry weather inflow
    RDII = 'RDII' # rainfall-dependent I/I information at nodes
    LOADINGS = 'LOADINGS' # initial pollutant loads on subcatchments
    CURVES = 'CURVES' # x-y tabular data referenced in other sections
    TIMESERIES = 'TIMESERIES' # time series data referenced in other sections

    NODE_OUTPUT = 'NODE_OUTPUT' #table containing time series data for the network nodes
    LINK_OUTPUT = 'LINK_OUTPUT' #table containing time series data for the network links
    SUBCATCHMENT_OUTPUT = 'SUBCATCHMENT_OUTPUT' #table containing time series data for the network subcatchments

    def initAlgorithm(self, config):

        self.addParameter(QgsProcessingParameterString(self.TITLE,'TITLE','SWMM Simulation'))
        layers = [layer for layer in QgsProject.instance().mapLayers().values()]

        flag=0
        for layer in layers:
            if layer.name().lower() == self.OPTIONS.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.OPTIONS,'Analysis options',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.OPTIONS,'Analysis options',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.REPORT.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.REPORT,'Output reporting instructions',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.REPORT,'Output reporting instructions',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.FILES.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.FILES,'Interface file options',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.FILES,'Interface file options',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.RAINGAGES.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.RAINGAGES,'Rain gage information',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.RAINGAGES,'Rain gage information',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.HYDROGRAPHS.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.HYDROGRAPHS,'Unit hydrograph data used to construct RDII inflows',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.HYDROGRAPHS,'Unit hydrograph data used to construct RDII inflows',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.EVAPORATION.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.EVAPORATION,'Evaporation data',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.EVAPORATION,'Evaporation data',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.TEMPERATURE.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.TEMPERATURE,'Air temperature and snow melt data',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.TEMPERATURE,'Air temperature and snow melt data',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.SUBCATCHMENTS.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.SUBCATCHMENTS,'Basic subcatchment information',[QgsProcessing.TypeVectorPolygon],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.SUBCATCHMENTS,'Basic subcatchment information',[QgsProcessing.TypeVectorPolygon],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.SUBAREAS.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.SUBAREAS,'Subcatchment impervious/pervious sub-area data',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.SUBAREAS,'Subcatchment impervious/pervious sub-area data',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.INFILTRATION.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.INFILTRATION,'Subcatchment infiltration parameters',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.INFILTRATION,'Subcatchment infiltration parameters',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.LID_CONTROLS.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.LID_CONTROLS,'Low impact development control information',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.LID_CONTROLS,'Low impact development control information',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.LID_USAGE.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.LID_USAGE,'Assignment of LID controls to subcatchments',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.LID_USAGE,'Assignment of LID controls to subcatchments',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.AQUIFERS.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.AQUIFERS,'Groundwater aquifer parameters',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.AQUIFERS,'Groundwater aquifer parameters',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.SNOWPACKS.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.SNOWPACKS,'Subcatchment snow pack parameters',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.SNOWPACKS,'Subcatchment snow pack parameters',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.JUNCTIONS.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.JUNCTIONS,'Junction node information',[QgsProcessing.TypeVectorPoint],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.JUNCTIONS,'Junction node information',[QgsProcessing.TypeVectorPoint],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.OUTFALLS.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.OUTFALLS,'Outfall node information',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.OUTFALLS,'Outfall node information',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.DIVIDERS.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.DIVIDERS,'Flow divider node information',[QgsProcessing.TypeVectorPoint],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.DIVIDERS,'Flow divider node information',[QgsProcessing.TypeVectorPoint],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.STORAGE.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.STORAGE,'Storage node information',[QgsProcessing.TypeVectorPoint],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.STORAGE,'Storage node information',[QgsProcessing.TypeVectorPoint],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.CONDUITS.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.CONDUITS,'Conduit link information',[QgsProcessing.TypeVectorLine],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.CONDUITS,'Conduit link information',[QgsProcessing.TypeVectorLine],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.PUMPS.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.PUMPS,'Pump link information',[QgsProcessing.TypeVectorPoint,QgsProcessing.TypeVectorLine],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.PUMPS,'Pump link information',[QgsProcessing.TypeVectorPoint,QgsProcessing.TypeVectorLine],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.ORIFICES.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.ORIFICES,'Orifice link information',[QgsProcessing.TypeVectorPoint,QgsProcessing.TypeVectorLine],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.ORIFICES,'Orifice link information',[QgsProcessing.TypeVectorPoint,QgsProcessing.TypeVectorLine],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.WEIRS.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.WEIRS,'Weir link information',[QgsProcessing.TypeVectorPoint,QgsProcessing.TypeVectorLine],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.WEIRS,'Weir link information',[QgsProcessing.TypeVectorPoint,QgsProcessing.TypeVectorLine],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.OUTLETS.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.OUTLETS,'Outlet link information',[QgsProcessing.TypeVectorPoint,QgsProcessing.TypeVectorLine],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.OUTLETS,'Outlet link information',[QgsProcessing.TypeVectorPoint,QgsProcessing.TypeVectorLine],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.XSECTIONS.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.XSECTIONS,'Conduit, orifice, and weir cross-section geometry',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.XSECTIONS,'Conduit, orifice, and weir cross-section geometry',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.TRANSECTS.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.TRANSECTS,'Transect geometry for conduits with irregular cross-sections',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.TRANSECTS,'Transect geometry for conduits with irregular cross-sections',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.LOSSES.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.LOSSES,'Conduit entrance/exit losses and flap valves',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.LOSSES,'Conduit entrance/exit losses and flap valves',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.CONTROLS.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.CONTROLS,'Rules that control pump and regulator operation',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.CONTROLS,'Rules that control pump and regulator operation',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.POLLUTANTS.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.POLLUTANTS,'Pollutant information',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.POLLUTANTS,'Pollutant information',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.LANDUSES.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.LANDUSES,'Land use categories',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.LANDUSES,'Land use categories',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.COVERAGES.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.COVERAGES,'Assignment of land uses to subcatchments',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.COVERAGES,'Assignment of land uses to subcatchments',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.BUILDUP.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.BUILDUP,'Buildup functions for pollutants and land uses',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.BUILDUP,'Buildup functions for pollutants and land uses',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.WASHOFF.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.WASHOFF,'Washoff functions for pollutants and land uses',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.WASHOFF,'Washoff functions for pollutants and land uses',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.TREATMENT.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.TREATMENT,'Pollutant removal functions at conveyance system nodes',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.TREATMENT,'Pollutant removal functions at conveyance system nodes',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.INFLOWS.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.INFLOWS,'External hydrograph/pollutograph inflow at nodes',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.INFLOWS,'External hydrograph/pollutograph inflow at nodes',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.DWF.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.DWF,'Baseline dry weather sanitary inflow at nodes',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.DWF,'Baseline dry weather sanitary inflow at nodes',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.PATTERNS.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.PATTERNS,'Periodic variation in dry weather inflow',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.PATTERNS,'Periodic variation in dry weather inflow',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.RDII.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.RDII,'Rainfall-dependent I/I information at nodes',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.RDII,'Rainfall-dependent I/I information at nodes',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.LOADINGS.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.LOADINGS,'Initial pollutant loads on subcatchments',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.LOADINGS,'Initial pollutant loads on subcatchments',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.CURVES.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.CURVES,'x-y tabular data referenced in other sections',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.CURVES,'x-y tabular data referenced in other sections',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.TIMESERIES.lower():
                flag=1
                self.addParameter(QgsProcessingParameterVectorLayer(self.TIMESERIES,'Time series data referenced in other sections',[QgsProcessing.TypeVector],layer.name()+ ' ['+layer.crs().authid()+']',True))
                break
        if flag==0: self.addParameter(QgsProcessingParameterVectorLayer(self.TIMESERIES,'Time series data referenced in other sections',[QgsProcessing.TypeVector],'',True))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.NODE_OUTPUT	.lower():
                flag=1
                self.addParameter(QgsProcessingParameterFeatureSink(self.NODE_OUTPUT,'Node_output_layer',QgsProcessing.TypeVectorPoint,layer.name()+ ' ['+layer.crs().authid()+']'))
                break
        if flag==0: self.addParameter(QgsProcessingParameterFeatureSink(self.NODE_OUTPUT,'Node_output_layer',QgsProcessing.TypeVector,''))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.LINK_OUTPUT	.lower():
                flag=1
                self.addParameter(QgsProcessingParameterFeatureSink(self.LINK_OUTPUT,'Link_output_layer',QgsProcessing.TypeVectorVector,layer.name()+ ' ['+layer.crs().authid()+']'))
                break
        if flag==0: self.addParameter(QgsProcessingParameterFeatureSink(self.LINK_OUTPUT,'Link_output_layer',QgsProcessing.TypeVector,''))

        flag=0
        for layer in layers:
            if layer.name().lower() == self.SUBCATCHMENT_OUTPUT.lower():
                flag=1
                self.addParameter(QgsProcessingParameterFeatureSink(self.SUBCATCHMENT_OUTPUT,'Subcatchment_output_layer',QgsProcessing.TypeVectorVector,layer.name()+ ' ['+layer.crs().authid()+']'))
                break
        if flag==0: self.addParameter(QgsProcessingParameterFeatureSink(self.SUBCATCHMENT_OUTPUT,'Subcatchment_output_layer',QgsProcessing.TypeVector,''))


        if not ProcessingConfig.getSetting('SWMM_CLI'):
            QgsMessageLog.logMessage('SWMM command line tool is not configured.\n\
             Please configure it before running SWMM algorithms.',tag="SWMM Processing")
            return

    def swmmTable(self,layer,parameters,context):
        if not layer: return u''
        pkidx = layer.dataProvider().pkAttributeIndexes()
        if not pkidx:
            pkidx=[]
            pkidx.append(layer.dataProvider().fields().indexFromName('id'))
            if int(pkidx[0])<0:
                pkidx=[]
                pkidx.append(layer.dataProvider().fields().indexFromName('fid'))

        #QgsMessageLog.logMessage(str(pkidx),tag="SWMM Processing")
        fields = ""
        for i,field in enumerate(layer.dataProvider().fields()):
            if not i in pkidx: fields+=field.name()+"\t"

        tbl =u'['+layer.name()+']\n'\
            ';'+fields+'\n'
        attr=[]
        for feature in layer.getFeatures():
                attr.append(feature.attributes())
        if  pkidx:
            attr.sort(key=lambda x: x[pkidx[0]])
        for i,v in enumerate(attr):
            for j,t in enumerate(attr[i]):
                if not j in pkidx:
                    if str(t) != 'NULL':
                        m = re.search('^(\d\d\d\d)-(\d\d)-(\d\d) (\d\d:\d\d):\d\d',str(t)) # for date and time saved as timestamps

                        if m:
                            tbl += '/'.join(m.group(2,3,1))+'\t'+m.group(4)+'\t'
                        else:
                            tbl += str(t)+'\t'
                    else: tbl += '\t'
            tbl += '\n'
        tbl += '\n'
        return tbl;

    def swmmKeyVal(self,layer,parameters,context, simul_title):
        if not layer: return u''
        pkidx = layer.dataProvider().pkAttributeIndexes()
        if not pkidx:
            pkidx=[]
            pkidx.append(layer.dataProvider().fields().indexFromName('id'))
            if int(pkidx[0])<0:
                pkidx=[]
                pkidx.append(layer.dataProvider().fields().indexFromName('fid'))
        fields = []
        k=[]
        for i,field in enumerate(layer.dataProvider().fields()):
            if not i in pkidx:
                k.append(i)
                fields.append(field.name())
        tbl =u'['+layer.name()+']\n'
        found = False
        if 0 not in k:
            idx=1
            offset=1
        else:
            idx=0
            offset=0
        for feature in layer.getFeatures():
            if str(feature[idx]) == simul_title:
                for i,v in enumerate(fields):
                    if i and str(v) != 'NULL': tbl += fields[i].upper()+'\t'+str(feature[i+offset])+'\n'
                    elif i : tbl += '\t'
                found = True
                tbl += '\n'
        tbl += '\n'
        k=None
        idx=None
        if not found:
            raise QgsProcessingException(
                    "No simulation named '"+simul_title+"' in "+layer.name())
        return tbl;


    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        swmm_cli = os.path.abspath(ProcessingConfig.getSetting('SWMM_CLI'))
        folder = ProcessingConfig.getSetting(ProcessingConfig.OUTPUT_FOLDER)
        filename = os.path.join(folder, 'swmm.inp')
        f = io.open(filename,'w',encoding='utf-8')
        f.write('[TITLE]\n')
        f.write(self.swmmKeyVal((self.parameterAsVectorLayer(parameters,self.OPTIONS,context)),parameters,context,self.parameterAsString(parameters,self.TITLE,context)))
        f.write(self.swmmKeyVal((self.parameterAsVectorLayer(parameters,self.REPORT,context)),parameters,context,self.parameterAsString(parameters,self.TITLE,context)))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.FILES,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.RAINGAGES,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.HYDROGRAPHS,context)),parameters,context))
        f.write(self.swmmKeyVal((self.parameterAsVectorLayer(parameters,self.EVAPORATION,context)),parameters,context,self.parameterAsString(parameters,self.TITLE,context)))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.TEMPERATURE,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.SUBCATCHMENTS,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.SUBAREAS,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.INFILTRATION,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.LID_CONTROLS,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.LID_USAGE,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.AQUIFERS,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.GROUNDWATER,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.SNOWPACKS,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.JUNCTIONS,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.OUTFALLS,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.DIVIDERS,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.STORAGE,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.CONDUITS,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.PUMPS,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.ORIFICES,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.WEIRS,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.OUTLETS,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.XSECTIONS,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.TRANSECTS,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.LOSSES,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.CONTROLS,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.POLLUTANTS,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.LANDUSES,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.COVERAGES,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.BUILDUP,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.WASHOFF,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.TREATMENT,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.INFLOWS,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.DWF,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.PATTERNS,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.RDII,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.LOADINGS,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.CURVES,context)),parameters,context))
        f.write(self.swmmTable((self.parameterAsVectorLayer(parameters,self.TIMESERIES,context)),parameters,context))
        f.close()

        outfilename = os.path.join(folder,'swmm.out')

        log=""
        error = False
        def demote(user_uid, user_gid):
            def result():
                os.setgid(user_gid)
                os.setuid(user_uid)
            return result
        loglines = []
        if platform=='linux' or platform=='darwin':
            user_name=getpass.getuser()
            pw_record = pwd.getpwnam(user_name)
            user_name      = pw_record.pw_name
            user_home_dir  = pw_record.pw_dir
            user_uid       = pw_record.pw_uid
            user_gid       = pw_record.pw_gid
            env = os.environ.copy()
            cwd=ProcessingConfig.getSetting(ProcessingConfig.OUTPUT_FOLDER)
            env[ 'HOME'     ]  = user_home_dir
            env[ 'PWD'      ]  = cwd
            env[ 'LOGNAME'  ]  = user_name
            env[ 'USER'     ]  = user_name
            with subprocess.Popen(
                [swmm_cli, filename, outfilename],
                shell=False,
                preexec_fn=demote(user_uid, user_gid),
                env=env,
                cwd=cwd,
                stdout=subprocess.PIPE,
                stdin=open(os.devnull),
                stderr=subprocess.STDOUT,
                universal_newlines=True,
                ) as swmm:
                for line in swmm.stdout:
                    feedback.pushConsoleInfo(line)
                    loglines.append(line)
                QgsMessageLog.logMessage('\n'.join(loglines),level=Qgis.Info)
                swmm.wait()
                returncode = swmm.returncode

        elif platform=='win32':
            si = subprocess.STARTUPINFO()
            si.dwFlags |= subprocess.STARTF_USESHOWWINDOW
            with subprocess.Popen(
                [swmm_cli,filename,outfilename],
                stdout=subprocess.PIPE,
                shell=True,
                stdin=open(os.devnull),
                stderr=subprocess.STDOUT,
                universal_newlines=True,
                startupinfo=si
                ) as swmm:
                for line in swmm.stdout:
                    feedback.pushConsoleInfo(line)
                    loglines.append(line)
                QgsMessageLog.logMessage('\n'.join(loglines),level=Qgis.Info)
                swmm.wait()
                returncode = swmm.returncode


        node_fields=QgsFields()
        node_fields.append(QgsField('id',QVariant.Int,'Integer'))
        node_fields.append(QgsField('Node',QVariant.String,'String'))
        node_fields.append(QgsField('Time', QVariant.String, 'String'))
        node_fields.append(QgsField('Inflow', QVariant.Double, 'Real'))
        node_fields.append(QgsField('Flooding', QVariant.Double, 'Real'))
        node_fields.append(QgsField('Depth', QVariant.Double, 'Real'))
        node_fields.append(QgsField('Head', QVariant.Double, 'Real'))

        (node_table, node_dest_id) = self.parameterAsSink(parameters, self.NODE_OUTPUT, context,node_fields)

        link_fields=QgsFields()
        link_fields.append(QgsField('id',QVariant.Int,'Integer'))
        link_fields.append(QgsField('Link',QVariant.String,'String'))
        link_fields.append(QgsField('Time', QVariant.String, 'String'))
        link_fields.append(QgsField('Flow', QVariant.Double, 'Real'))
        link_fields.append(QgsField('Velocity', QVariant.Double, 'Real'))
        link_fields.append(QgsField('Depth', QVariant.Double, 'Real'))
        link_fields.append(QgsField('CapacitySetting', QVariant.Double, 'Real'))

        (link_table, link_dest_id) = self.parameterAsSink(parameters, self.LINK_OUTPUT, context,link_fields)

        subcatchment_fields=QgsFields()
        subcatchment_fields.append(QgsField('id',QVariant.Int,'Integer'))
        subcatchment_fields.append(QgsField('Subcatchment',QVariant.String,'String'))
        subcatchment_fields.append(QgsField('Time', QVariant.String, 'String'))
        subcatchment_fields.append(QgsField('Precip', QVariant.Double, 'Real'))
        subcatchment_fields.append(QgsField('Losses', QVariant.Double, 'Real'))
        subcatchment_fields.append(QgsField('Runoff', QVariant.Double, 'Real'))

        (subcatchment_table, subcatchment_dest_id) = self.parameterAsSink(parameters, self.SUBCATCHMENT_OUTPUT, context,subcatchment_fields)
        total_size = os.path.getsize(outfilename)
        total_read = 0
        o = io.open(outfilename,'r',encoding='utf-8')
        o.seek(0)
        # get nodes results
        link_id = ''
        node_id = ''
        subcatchment_id=''
        line = o.readline()
        m=1
        n=1
        p=1
        while line:
            line = line.rstrip()
            if (node_id or link_id or subcatchment_id) and not line:
                link_id = ''
                node_id = ''
                subcatchment_id=''
            if re.search('^  <<< Node ', line):
                node_id = line[11:-4]
                for i in range(5): line = o.readline()
                line = line.rstrip()
            if re.search('^  <<< Link ', line):
                link_id = line[11:-4]
                for i in range(5): line = o.readline()
                line = line.rstrip()
            if re.search('^  <<< Subcatchment ', line):
                subcatchment_id = line[19:-4]
                for i in range(5): line = o.readline()
                line = line.rstrip()
            if node_id:
                feature = QgsFeature(node_fields)
                tbl = line.split()
                if len(tbl) >= 6:
                    feature['id']=m
                    m=m+1
                    feature['Node']     = node_id
                    if platform=='win32':
                        feature['Time']     = convert_date(tbl[0])+' '+tbl[1]
                    elif platform=='linux' or platform=='darwin':
                        temp=re.search('^(\d\d)/(\d\d)/(\d\d\d\d)$',tbl[0])
                        feature['Time'] = temp.group(3)+'-'+temp.group(1)+'-'+temp.group(2)+ ' '+tbl[1]
                    feature['Inflow']   = tbl[2]
                    feature['Flooding'] = tbl[3]
                    feature['Depth']    = tbl[4]
                    feature['Head']     = tbl[5]
                    node_table.addFeatures([feature])
            if link_id:
                feature = QgsFeature(link_fields)
                tbl = line.split()
                if len(tbl) >= 6:
                    feature['id']     = n
                    n=n+1
                    feature['Link']     = link_id
                    if platform=='win32':
                        feature['Time']     = convert_date(tbl[0])+' '+tbl[1]
                    elif platform=='linux' or platform=='darwin':
                        temp=re.search('^(\d\d)/(\d\d)/(\d\d\d\d)$',tbl[0])
                        feature['Time'] = temp.group(3)+'-'+temp.group(1)+'-'+temp.group(2)+ ' '+tbl[1]
                    feature['Flow']     = tbl[2]
                    feature['Velocity'] = tbl[3]
                    feature['Depth']    = tbl[4]
                    feature['CapacitySetting'] = tbl[5]
                    link_table.addFeatures([feature])
            if subcatchment_id:
                feature = QgsFeature(subcatchment_fields)
                tbl = line.split()
                if len(tbl) >= 5:
                    feature['id']     = p
                    p=p+1
                    feature['Subcatchment']     = subcatchment_id
                    if platform=='win32':
                        feature['Time']     = convert_date(tbl[0])+' '+tbl[1]
                    elif platform=='linux' or platform=='darwin':
                        temp=re.search('^(\d\d)/(\d\d)/(\d\d\d\d)$',tbl[0])
                        feature['Time'] = temp.group(3)+'-'+temp.group(1)+'-'+temp.group(2)+ ' '+tbl[1]
                    feature['Precip']     = tbl[2]
                    feature['Losses'] = tbl[3]
                    feature['Runoff']    = tbl[4]
                    subcatchment_table.addFeatures([feature])
            line = o.readline()
            total_read += len(line)
        o.close()

        return {self.NODE_OUTPUT: node_dest_id,self.LINK_OUTPUT: link_dest_id,self.SUBCATCHMENT_OUTPUT: subcatchment_dest_id}
    def icon(self):
        return QIcon(":/plugins/ldtoolbox/swmm.png")
    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'swmmsim'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr('Run SWMM simulation')
    def shortHelpString(self):
        file=os.path.realpath(__file__)
        file = os.path.join(os.path.dirname(file),'Qgs3SwmmAlgorithm.help')
        if not os.path.exists(file):
            return ''
        with open(file) as helpf:
            help=helpf.read()
        return help

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'SWMM'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return Qgs3SwmmAlgorithm()
